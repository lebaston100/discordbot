import logging
import embedBuilder
import re
import asyncio
import json
import aiohttp
import discord
from discord import app_commands
from discord.ext import commands
from typing import Union

logger = logging.getLogger("NinjaBot." + __name__)

class NinjaDocs(commands.Cog):
    def __init__(self, bot) -> None:
        logger.debug(f"Loading {self.__class__.__name__}")
        self.bot = bot
        self.isInternal = False
        self.http = aiohttp.ClientSession()
        self.ninjaDocsBaseUrl = "https://docs.vdo.ninja/"
        self.gbBaseUrl = "https://api.gitbook.com/v1/"
        self.gbHeaders = {
                "Authorization": f"Bearer {self.bot.config.get('gitbookApiKey')}"
            }

    def _checkIfInATEC(interaction: discord.Interaction) -> bool:
        return str(interaction.channel_id) not in interaction.client.config.get("autoThreadEnabledChannels")

    # app command for manually asking questions to gitbook lens
    @app_commands.command()
    @app_commands.describe(question="The question you want to ask")
    @app_commands.guild_only()
    @app_commands.checks.cooldown(1, 5.0, key=lambda i: (i.guild_id, i.user.id))
    @app_commands.check(_checkIfInATEC)
    async def ask(self, interaction: discord.Interaction, question: str) -> None:
        """Ask ninjabot a question"""
        await interaction.response.defer()
        la = await self.getLensAnswer(question)
        if la:
            embed = embedBuilder.ninjaEmbed(description=self.createEmbedTextFromLensResult(la))
            await interaction.followup.send(embed=embed)
            return
        await interaction.followup.send("Could not generate an answer ●︿●\nTry making your question more specific.")

    # app command for a normal docs search
    @app_commands.command()
    @app_commands.describe(query="The search query")
    @app_commands.guild_only()
    @app_commands.checks.cooldown(1, 5.0, key=lambda i: (i.guild_id, i.user.id))
    @app_commands.check(_checkIfInATEC)
    async def searchdocs(self, interaction: discord.Interaction, query: str) -> None:
        """Search the documentation"""
        await interaction.response.defer()
        sr = await self.searchRequest(query)
        if sr:
            embed = embedBuilder.ninjaEmbed(description=self.createEmbedTextFromSearchResult(sr))
            await interaction.followup.send(embed=embed)
            return
        await interaction.followup.send("Could not find a result to your query, try /ask ●︿●")

    # formats the lens result into a discord embed
    def createEmbedTextFromLensResult(self, result: dict) -> str:
        t = f"{result['text']}\n\nReferences:\n"
        for url in result["urls"]:
            t += f"{url}\n"
        t += "\nThe above response was generated by a LLM, so take it with a grain of salt!"
        return t

    # formats a docs search result into a discord embed
    def createEmbedTextFromSearchResult(self, results: dict) -> str:
        t = "Documentation search results:\n"
        for result in results["items"][:5]:
            t += f"{result['title']}: {self.ninjaDocsBaseUrl}{result['path']}\n"
        return t

    # request answer from lens and process it
    async def getLensAnswer(self, message: str=None) -> Union[dict, None]:
        # don't proceed if we don't have a message
        if not message: return None

        # remove common phrases not needed for lens
        regex = r"((hello)|(hey)|(help)|(steve)|(hi)|(everyone)|(thanks))\b,?!?\s?"
        message = re.sub(regex, "", message, 0, re.IGNORECASE)

        # questions need to be at least 2 words long
        if not re.match(r"(?:\w+\s+){2,}", message): return None
        logger.debug(f"Question: {message}")

        # query lens
        answer = {}
        answer["urls"] = []
        lensData = await self.lensRequest(message)
        if lensData:
            logger.debug(json.dumps(lensData, indent=2))
            answer["text"] = lensData["text"] # get text
            if len(lensData["pages"]):
                # resolve top 3 pages to urls
                coros = [self.getUrlAndDescFromPageId(page["page"]) for page in lensData["pages"][:3]]
                answer["urls"] = await asyncio.gather(*coros)
            return answer
        return None

    # ask lens the provided question
    async def lensRequest(self, query: str) -> Union[dict, None]:
        try:
            response = await self.doGbPostApiRequest(f"spaces/{self.bot.config.get('gitbookSpaceId')}/search/ask", {"query": query})
            if response and "answer" in response: return response["answer"]
        except Exception as E:
            logger.exception(E)
            return None
    
    # normal docs search
    async def searchRequest(self, query: str) -> Union[dict, None]:
        try:
            response = await self.doGbGetApiRequest(f"spaces/{self.bot.config.get('gitbookSpaceId')}/search", {"query": query})
            if response and "items" in response: return response
        except Exception as E:
            logger.exception(E)
            return None

    # resolve a gitbook page id to a usable url
    async def getUrlAndDescFromPageId(self, pageId: str) -> Union[list, None]:
        try:
            response = await self.doGbGetApiRequest(f"spaces/{self.bot.config.get('gitbookSpaceId')}/content/page/{pageId}", None)
            if response: return self.ninjaDocsBaseUrl + response["path"]
            return None
        except Exception as E:
            logger.exception(E)
            return None

    # perform a get request to the gitbook api
    async def doGbGetApiRequest(self, endpoint: str, params: dict) -> Union[dict, None]:
        try:
            async with self.http.get(self.gbBaseUrl + endpoint, params=params, headers=self.gbHeaders) as resp:
                apiResponse = await resp.json(content_type="application/json")
                if resp.status == 200: return apiResponse
                return None
        except Exception as E:
            logger.exception(E)
            return None

    # perform a post request to the gitbook api
    async def doGbPostApiRequest(self, endpoint: str, data: dict) -> Union[dict, None]:
        try:
            async with self.http.post(self.gbBaseUrl + endpoint, json=data, headers=self.gbHeaders) as resp:
                apiResponse = await resp.json(content_type="application/json")
                logger.info(f"'X-Ratelimit-Limit': '{resp.headers.get('X-Ratelimit-Limit')}', "\
                            f"'X-Ratelimit-Remaining': '{resp.headers.get('X-Ratelimit-Remaining')}', "\
                            f"'X-Ratelimit-Reset': '{resp.headers.get('X-Ratelimit-Reset')}'")
                if resp.status == 200: return apiResponse
                return None
        except Exception as E:
            logger.exception(E)
            return None

    async def cog_command_error(self, ctx, error) -> None:
        """Post error that happen inside this cog to channel"""
        await ctx.send(error)

    async def getCommands(self) -> list:
        """Return the available commands as a list"""
        return []

    async def cog_unload(self) -> None:
        logger.debug(f"Shutting down {self.__class__.__name__}")

async def setup(bot) -> None:
    await bot.add_cog(NinjaDocs(bot))